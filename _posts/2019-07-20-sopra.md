---
layout: post
title:  "SoPra Review"
date:   2019-07-20 22:00:00 +0200
categories: uni
---
The SoPra ("Software Projekt") is a module at Ulm University which requires groups of students to develop a software project over the course of a year. The module is mandatory for all students doing a computer science, software engineering or similar software development oriented program.
This includes "Informationssystemtechik", the program i am doing. I did the project in the last year with a group of five fellow students and took the chance to try some new strategies, for the software development itself as well as for the project management. In this blog post i will review the differenct aspects and summarize my experiences.

## Our Project
Every year the task is to write an online multiplayer game. These games consist of a server for managing the game and a client for playing the game. Additionally an AI for playing the game and an editor for parts of the game (for example the players) needs to be developed. Each team needs to develop the client and the AI, and one of the server and the editor. The other component can be "bought" from another team, but needs to be maintained and extended.

For our year the game was based on the idea of [quidditch](https://en.wikipedia.org/wiki/Quidditch). The game is turn based, thus no real time constraints need to be kept.

## Deciding on a language
The initial problem for our team was to decide on a language and technology stack for the application. The constraints given by the specification where:
 * The server and the client communicate with [WebSockets](https://en.wikipedia.org/wiki/WebSocket)
 * The clients provides an graphical user interface
 * The server and the AI can run in a [Docker](https://en.wikipedia.org/wiki/Docker_(software)) container

The obvious choice, which was also the one choosen by most teams, is java as this is the language we learned during our introductory programming courses. As we are not happy with java (in short: implicit reference types, no operator overloading, weak template system, overly complex buildsystems) we quickly decided on not to use java. Initially decided to use only one language as this would allow us to reuse most of our code for all components. Proposed alternatives where:
 * Kotlin: java but better
 * C#: java but from microsoft
 * Javascript: not java, even though the name suggest it
 * Python: not a new language, but certainly on the rise
 * C++: mature and do-it-all language

Kotlin was ruled out due to the lack of an usable GUI-Framework as Kotlin is quite young. 
C# was ruled out due to the fact that we planned to develop all components cross platform and everything but Windows is still not fully supported, especially for GUIs. 
Javascript was ruled out due to the fact that we were not interested to descent into the weakly typed dependency hell that is javascript. 
Python was primarily ruled out due to the fact that many people of our team had zero experience with python additionally we feared the poor performance, especially for our AI.
So the last option without any major drawbacks was C++, so that is the language we decided on.

To mitigate the problems C++ is famous for, such as memory leaks, segmentation faults and undefined behaviour we decided to rely on the latest standard: C++17. This enabled us to use the tools provided by modern C++ such as shared pointers. Additionally we heavily relied on [AddressSanitizer](https://en.wikipedia.org/wiki/AddressSanitizer) to detect memory issues. As a build system we used CMake.

Initially we planned on using [SFML](https://www.sfml-dev.org/) as a GUI-Framework. The member of our team primarily responsible for frontend design was unhappy with the options for styling the UI so he decided to write our client in javascript using VueJs as the framework.

## Our Git Workflow
It was mandatory to manage our code base using Git, something everybody in the team agreed on beeing the right choice. As we only had one repository for the complete project on the gitlab instance of the university we decided to do our main development on github. This allowed us to use as many repositorys as necessary and furthermore provided a better issue tracker and a better system for merge-/pull-requests.

We decided on using [Git Flow](https://nvie.com/posts/a-successful-git-branching-model/) for managing our branches: the master branch is the stable branch, more recent changes are on the develop branch and the actual development is done on feature branches. 
Even though some members of our team were not very experienced with using git we still had very little issues, especially close to zero merge conflicts. 
Additionally this concept allowed us to review all changes before merging them, so the more experienced members of our team could give advise to the other team members.

## Code Review
? Reviews (Muss halt auch jeder ordentlich machen)

## Continuous Integration
+ CI

## Documentation
? Doxygen (liest doch eh niemand?!)

## Reusing Components
- Shared Librarys (Alles immer veraltet, was gibt es stattdessen, monolith? submodule?)

## Unit Test
+ Aber halt sinnvoll
